<!doctype html>
<html lang="en">
<head>
 <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-D63MJPZ47S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-D63MJPZ47S');
</script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EmojiPick ‚Äî Compare</title>
  <link rel="stylesheet" href="styles.v11.css" />
  <style>
    .pageWrap{max-width:980px;margin:22px auto;padding:0 16px;}
    .headerRow{display:flex;align-items:center;justify-content:space-between;gap:16px;margin-bottom:14px;}
    .brand{display:flex;align-items:center;gap:10px;}
    .logo{width:28px;height:28px;border-radius:10px;display:inline-flex;align-items:center;justify-content:center;background:#F3F4F6;}
    .brandTitle{font-weight:800;}
    .brandSub{font-size:12px;opacity:.7;margin-top:2px;}
    .btn{appearance:none;border:1px solid #CBD5E1;background:white;border-radius:999px;padding:8px 12px;font-weight:700;cursor:pointer;}
    .btnPrimary{background:#111827;color:white;border-color:#111827;}
    .card{border:1px solid #E5E7EB;border-radius:16px;padding:16px;background:white;box-shadow:0 8px 22px rgba(0,0,0,.05);}
    .card + .card{margin-top:14px;}
    h1{font-size:22px;margin:0 0 8px 0;}
    .hint{font-size:13px;opacity:.75;margin-top:4px;}
    label{display:block;font-weight:700;margin:10px 0 6px;}
    input,select{width:100%;padding:10px 12px;border:1px solid #D1D5DB;border-radius:12px;}
    .row{display:grid;grid-template-columns:1fr 240px;gap:14px;align-items:end;}
    @media (max-width:720px){.row{grid-template-columns:1fr;}}
    .results{margin-top:12px;padding:12px;border-radius:12px;background:#F8FAFC;border:1px solid #E2E8F0;}
    .pillRow{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px;}
    .pill{display:inline-flex;align-items:center;justify-content:center;min-width:38px;padding:6px 10px;border:1px solid #E5E7EB;border-radius:999px;background:white;font-weight:800;}
    .pill.hit{border-color:#22C55E;}
    .pill.miss{opacity:.6;}
    .footerLinks{display:flex;gap:12px;justify-content:space-between;margin-top:18px;font-size:13px;}
    .footerLinks a{color:#2563EB;}

    /* Saved picks history table */
    .tableWrap{overflow:auto;border:1px solid #E2E8F0;border-radius:12px;margin-top:10px;max-height:360px;}
    table{width:100%;border-collapse:collapse;min-width:820px;}
    th, td{padding:10px;text-align:left;border-bottom:1px solid #E5E7EB;vertical-align:top;}
    thead th{position:sticky;top:0;background:#F8FAFC;border-bottom:1px solid #E2E8F0;}
    tr.clickable{cursor:pointer;}
    tr.clickable:hover{background:#F8FAFC;}
    .tag{display:inline-block;font-weight:800;font-size:12px;border:1px solid #E5E7EB;background:white;border-radius:999px;padding:3px 8px;margin-left:6px;}
  </style>
</head>
<body>
  <div class="pageWrap">
    <div class="headerRow">
      <div class="brand">
        <div class="logo">‚ú®</div>
        <div>
          <div class="brandTitle">EmojiPick</div>
          <div class="brandSub">Check matches vs winning numbers</div>
        </div>
      </div>
      <button class="btn" onclick="location.href='index.html'">Back</button>
    </div>

    <!-- 0) Saved picks history -->
    <div class="card" id="picksHistoryCard" style="display:none;">
      <div style="display:flex;gap:12px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap;">
        <div>
          <div class="hint">Your saved picks list (click a row to load that pick below).</div>
          <h1 style="margin-top:6px;">0) Saved picks history</h1>
        </div>
        <button class="btn" id="picksToggle" type="button">Hide</button>
      </div>

      <div id="picksHistoryWrap" style="display:block;">
        <div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
          <input id="picksSearch" placeholder="Search by date, emoji, or number‚Ä¶" style="flex:1;min-width:240px;" />
          <button class="btn" id="picksClear" type="button">Clear</button>
        </div>

        <div class="tableWrap">
          <table>
            <thead>
              <tr>
                <th style="width:160px;">Saved</th>
                <th style="width:120px;">Game</th>
                <th>Pick</th>
                <th style="width:240px;">Best records</th>
              </tr>
            </thead>
            <tbody id="picksTbody"></tbody>
          </table>
        </div>
        <div class="hint" id="picksCountHint" style="margin-top:8px;"></div>
      </div>
    </div>

    <div class="card">
      <div class="hint">Steps: choose a saved pick ‚Üí we auto-load winning numbers ‚Üí compare.</div>
      <h1>1) Choose a saved pick</h1>
      <select id="pickSelect"></select>
      <div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
        <button class="btn" id="sharePickBtn" type="button">Share this pick</button>
        <span class="hint" id="shareHint" style="margin:0;">Copy a shareable summary to your clipboard.</span>
      </div>
      <div class="hint" id="noPicksHint" style="display:none;margin-top:10px;">No saved picks yet. Go back, generate numbers, and click <b>Save</b>.</div>
    </div>

    <div class="card">
      <h1>2) Winning numbers</h1>
      <div class="hint" id="autoHint">We auto-fill the latest published winning numbers for this game. (You can optionally edit.)</div>

      <div class="results" id="latestBox" style="display:block;margin-top:12px;">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;">
          <div>
            <div style="font-weight:800;">Latest winning numbers</div>
            <div class="hint" id="latestMeta">Loading‚Ä¶</div>
          </div>
          <button class="btn" id="refreshLatest" type="button">Refresh</button>
        </div>
        <div class="pillRow" id="latestPills" style="margin-top:10px;"></div>
      </div>

      <div style="margin-top:12px;display:flex;align-items:center;gap:10px;">
        <input id="manualToggle" type="checkbox" style="width:auto;" />
        <label for="manualToggle" style="margin:0;font-weight:700;">Edit winning numbers manually</label>
      </div>

      <div class="row" id="manualRow" style="margin-top:8px;opacity:.65;pointer-events:none;">
        <div style="flex:2;min-width:240px;">
          <label for="winMain">Main numbers</label>
          <input id="winMain" class="input" placeholder="Auto-filled" inputmode="numeric" />
          <div class="hint">Format examples: <b>1 2 3 4 5</b>, or <b>1,2,3,4,5</b></div>
        </div>
        <div style="flex:1;min-width:180px;">
          <label for="winBonus" id="bonusLabel">Bonus (optional)</label>
          <input id="winBonus" class="input" placeholder="Auto-filled" inputmode="numeric" />
        </div>
      </div>

      <div style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;">
        <button class="btn btnPrimary" id="compareBtn">Compare</button>
        <button class="btn" id="clearBtn" type="button">Clear</button>
      </div>

      <div class="results" id="results" style="display:none;"></div>

      <div class="results" id="hotBox" style="display:block;margin-top:14px;">
        <div style="font-weight:800;">Hot numbers (historical)</div>
        <div class="hint" id="hotMeta">Loading‚Ä¶</div>
        <div class="pillRow" id="hotPills" style="margin-top:10px;"></div>
        <div class="hint" id="hotMatchHint" style="margin-top:8px;"></div>
      </div>
    </div>

    <div class="card" id="insightsCard" style="display:none;">
      <h1>3) Insights</h1>
      <div class="results" id="whyBox" style="display:block;"></div>
      <div class="results" id="challengeBox" style="display:block;margin-top:12px;"></div>
    </div>

    <div class="card">
      <h1>4) Closest past draws</h1>
      <div class="hint" id="closestMeta">Loading‚Ä¶</div>
      <div class="hint" id="closestLegend"></div>
      <div id="closestList" class="results" style="display:block;margin-top:10px;"></div>
    </div>

    <div class="card">
      <div style="display:flex;gap:12px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap;">
        <div>
          <h1 style="margin-bottom:4px;">5) Full draw history <span class="hint">(optional)</span></h1>
          <div class="hint">For transparency and exploring past draws. (Top matches are already shown above.)</div>
        </div>
        <button class="btn" id="historyToggle" type="button">Show</button>
      </div>
      <div id="historyWrap" style="display:none;margin-top:10px;">
        <div class="hint" id="historyMeta">Loading‚Ä¶</div>
        <div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
          <input id="historySearch" placeholder="Search by date or draw #" style="flex:1;min-width:240px;" />
          <button class="btn" id="historyClear" type="button">Clear</button>
          <button class="btn" id="historyMore" type="button">Load more</button>
        </div>
        <div style="margin-top:10px;overflow:auto;max-height:380px;border:1px solid #E2E8F0;border-radius:12px;">
          <table style="width:100%;border-collapse:collapse;min-width:680px;" id="historyTable">
            <thead>
              <tr style="position:sticky;top:0;background:#F8FAFC;border-bottom:1px solid #E2E8F0;">
                <th style="text-align:left;padding:10px;">Date</th>
                <th style="text-align:left;padding:10px;">Draw #</th>
                <th style="text-align:left;padding:10px;">Winning</th>
                <th style="text-align:left;padding:10px;">Matches</th>
              </tr>
            </thead>
            <tbody id="historyTbody"></tbody>
          </table>
        </div>
        <div class="hint" id="historyCountHint" style="margin-top:8px;"></div>
      </div>
    </div>

    <div class="footerLinks">
      <div>
        <a href="privacy.html">Privacy policy</a>
        &nbsp;&nbsp;
        <a href="terms.html">Terms and Conditions</a>
      </div>
      <div>Build v27</div>
    </div>
  </div>

<script>
(()=>{

  const LS_KEY = 'emojipick_picks_v1';

  const GAME = {
    pb: { name: 'Powerball', mainCount: 5, bonusLabel: 'Powerball', dataKey: 'powerball' },
    mm: { name: 'Mega Millions', mainCount: 5, bonusLabel: 'Mega Ball', dataKey: 'megamillions' },
    tx: { name: 'TX Instant (Demo)', mainCount: 5, bonusLabel: null, dataKey: null }
  };

  // -------- Elements
  const pickSelect = document.getElementById('pickSelect');
  const sharePickBtn = document.getElementById('sharePickBtn');
  const shareHint = document.getElementById('shareHint');
  const insightsCard = document.getElementById('insightsCard');
  const whyBox = document.getElementById('whyBox');
  const challengeBox = document.getElementById('challengeBox');

  const winMainInput = document.getElementById('winMain');
  const winBonusInput = document.getElementById('winBonus');
  const compareBtn = document.getElementById('compareBtn');
  const clearBtn = document.getElementById('clearBtn');
  const results = document.getElementById('results');

  const latestMeta = document.getElementById('latestMeta');
  const latestPills = document.getElementById('latestPills');
  const refreshLatestBtn = document.getElementById('refreshLatest');

  const manualToggle = document.getElementById('manualToggle');
  const manualRow = document.getElementById('manualRow');

  const hotMeta = document.getElementById('hotMeta');
  const hotPills = document.getElementById('hotPills');
  const hotMatchHint = document.getElementById('hotMatchHint');

  const closestMeta = document.getElementById('closestMeta');
  const closestLegend = document.getElementById('closestLegend');
  const closestList = document.getElementById('closestList');

  const historyMeta = document.getElementById('historyMeta');
  const historySearch = document.getElementById('historySearch');
  const historyClear = document.getElementById('historyClear');
  const historyMore = document.getElementById('historyMore');
  const historyTbody = document.getElementById('historyTbody');
  const historyCountHint = document.getElementById('historyCountHint');
  const historyToggle = document.getElementById('historyToggle');
  const historyWrap = document.getElementById('historyWrap');

  // Saved picks history UI
  const picksHistoryCard = document.getElementById('picksHistoryCard');
  const picksToggle = document.getElementById('picksToggle');
  const picksHistoryWrap = document.getElementById('picksHistoryWrap');
  const picksSearch = document.getElementById('picksSearch');
  const picksClear = document.getElementById('picksClear');
  const picksTbody = document.getElementById('picksTbody');
  const picksCountHint = document.getElementById('picksCountHint');

  // -------- State
  let picks = [];
  let currentPick = null;
  let currentWinning = null;
  let currentStats = null;
  let currentHistory = null;

  let historyFiltered = [];
  let historyShown = 0;
  const HISTORY_PAGE = 200;

  // Cache per game for faster best computations
  const gameHistoryCache = new Map(); // gameCode -> { meta, draws: normalized }
  const gameStatsCache = new Map();   // gameCode -> stats
  const gameLatestCache = new Map();  // gameCode -> latest draw

  // Fallback pool used only if older saved picks store emoji indexes but not the emoji characters
  const FALLBACK_EMOJI_POOL = ['‚ú®','üåü','üåà','üî•','üíé','üçÄ','üéØ','üöÄ','üé≤','üéâ','üèÜ','üéÅ','üßø','ü™ô','‚≠ê','‚òÄÔ∏è','üåô','‚ö°','üåä','üçé','üçâ','üçá','üçì','ü•ë','üçî','üçï','üç£','üéµ','üé®','üß†','üí°','üìå','üß©','üïπÔ∏è','üõ°Ô∏è','üß™','üìà','üìö','üèÅ','üß∏'];

  // -------- Helpers
  const safeJsonParse = (s, fallback) => { try { return JSON.parse(s); } catch { return fallback; } };

  const esc = (s) => String(s==null?'':s)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');

  const fmtDate = (iso) => {
    if(!iso) return '';
    const d = new Date(String(iso).slice(0,10) + 'T00:00:00');
    if (Number.isNaN(d.getTime())) return String(iso);
    return d.toLocaleDateString(undefined, { year:'numeric', month:'short', day:'2-digit' });
  };

  // robust time conversion
  const toTime = (x) => {
    if (x == null) return NaN;
    if (typeof x === 'number') {
      const s = String(x);
      if (/^\d{8}$/.test(s)) return new Date(`${s.slice(0,4)}-${s.slice(4,6)}-${s.slice(6,8)}T00:00:00`).getTime();
      return x; // assume epoch ms
    }
    const s = String(x).trim();
    if (!s) return NaN;
    if (/^\d{8}$/.test(s)) return new Date(`${s.slice(0,4)}-${s.slice(4,6)}-${s.slice(6,8)}T00:00:00`).getTime();
    // if already yyyy-mm-dd
    if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return new Date(`${s}T00:00:00`).getTime();
    return new Date(s).getTime();
  };

  const getGame = (code) => GAME[code] || { name: code, mainCount: 5, bonusLabel: null, dataKey: null };

  const pill = (text, isHit=false) => {
    const span = document.createElement('span');
    span.className = 'pill' + (isHit ? ' hit' : '');
    span.textContent = String(text);
    return span;
  };

  const setManualEnabled = (enabled) => {
    manualRow.style.opacity = enabled ? '1' : '.65';
    manualRow.style.pointerEvents = enabled ? 'auto' : 'none';
    winMainInput.readOnly = !enabled;
    winBonusInput.readOnly = !enabled;
  };

  const getPickStartDateISO = (pick) => {
    if(!pick) return '';
    if(typeof pick.date === 'string' && pick.date.trim().length>=10) return pick.date.trim().slice(0,10);
    if(typeof pick.savedAt === 'string' && pick.savedAt.trim().length>=10) return pick.savedAt.trim().slice(0,10);
    return '';
  };

  // Normalize saved pick schema (legacy + new)
  const normalizePick = (raw) => {
    if (!raw || typeof raw !== 'object') return null;

    const game = (raw.game || raw.gameId || raw.draw || 'pb');
    const date = (raw.date || raw.dateSeed || raw.savedDate || '');

    const idxs = (Array.isArray(raw.idxs) ? raw.idxs : (Array.isArray(raw.emojiIdxs) ? raw.emojiIdxs : []));
    let emojis = Array.isArray(raw.emojis) ? raw.emojis : [];
    if (!emojis.length && idxs.length) {
      emojis = idxs.map(i => FALLBACK_EMOJI_POOL[Math.abs(Number(i) || 0) % FALLBACK_EMOJI_POOL.length]);
    }

    const numbers =
      Array.isArray(raw.numbers) ? raw.numbers :
      (raw.nums && Array.isArray(raw.nums.main)) ? raw.nums.main :
      Array.isArray(raw.mainNumbers) ? raw.mainNumbers : [];

    const bonus = (raw.powerball ?? raw.pb ?? raw.bonus ?? (raw.nums ? raw.nums.bonus : null));

    const out = {
      id: raw.id || '',
      game,
      date,
      emojis,
      numbers,
      bonus,
      savedAt: raw.savedAt || raw.createdAt || '',
    };

    if (!Array.isArray(out.numbers) || out.numbers.length === 0) return null;
    return out;
  };

  const sortKey = (p) => {
    const d = (p.date || '').replace(/[^0-9]/g, '').padEnd(8, '0');
    const t = String(p.savedAt || 0).padStart(13, '0');
    return d + '-' + t;
  };

  const readPicks = () => {
    const candidateKeys = [ LS_KEY, 'emojiPick_picks_v1', 'emojiPick_picks', 'emojipick_picks' ];
    let raw = [];
    try {
      for (const k of candidateKeys) {
        const v = localStorage.getItem(k);
        if (v) { raw = safeJsonParse(v, []); break; }
      }
    } catch { raw = []; }

    const arr = Array.isArray(raw) ? raw : [];
    const out = arr.map(normalizePick).filter(Boolean);
    out.sort((a,b) => sortKey(b).localeCompare(sortKey(a)));
    return out;
  };

  const optionLabel = (p) => {
    const g = getGame(p.game);
    const emojis = (p.emojis || []).join(' ');
    const main = (p.numbers || []).join('-');
    const bonus = (p.bonus !== undefined && p.bonus !== null && p.bonus !== '') ? ` + ${g.bonusLabel || 'Bonus'} ${p.bonus}` : '';
    const saved = getPickStartDateISO(p);
    return `${g.name} ‚Ä¢ ${saved || ''} ‚Ä¢ ${emojis} ‚Ä¢ ${main}${bonus}`.replace(/\s+/g,' ').trim();
  };

  const renderPickDropdown = () => {
    pickSelect.innerHTML = '';
    const ph = document.createElement('option');
    ph.value = '';
    ph.textContent = (picks.length ? 'Pick‚Ä¶' : 'No saved picks yet ‚Äî go back and save one');
    pickSelect.appendChild(ph);

    picks.forEach((p, idx) => {
      const opt = document.createElement('option');
      opt.value = String(idx);
      opt.textContent = optionLabel(p);
      pickSelect.appendChild(opt);
    });
  };

  // ----- Draw normalization (very important)
  const normalizeDraw = (gameCode, d) => {
    if(!d || typeof d !== 'object') return null;

    // date
    const draw_date = (d.draw_date || d.date || d.drawDate || '').toString().slice(0,10);

    // draw number
    const draw_no = (d.draw_no ?? d.draw ?? d.drawNumber ?? d.drawNo ?? '');

    // main numbers
    let main =
      Array.isArray(d.main_numbers) ? d.main_numbers :
      Array.isArray(d.numbers) ? d.numbers :
      Array.isArray(d.main) ? d.main :
      (typeof d.winning_numbers === 'string' ? d.winning_numbers.trim().split(/\s+/).slice(0,5).map(Number) : []);
    main = (main || []).map(Number).filter(n => Number.isFinite(n));

    // bonus
    let bonus = (d.bonus_number ?? d.bonus ?? d.powerball ?? d.pb ?? d.megaball ?? null);
    if (bonus == null && typeof d.winning_numbers === 'string') {
      const parts = d.winning_numbers.trim().split(/\s+/).map(Number).filter(n => Number.isFinite(n));
      if (parts.length >= 6) bonus = parts[5];
    }
    if (bonus != null) bonus = Number(bonus);
    if (!Number.isFinite(bonus)) bonus = null;

    // for UI label
    const g = getGame(gameCode);
    return { draw_date, draw_no, main_numbers: main, bonus_number: bonus, bonus_label: g.bonusLabel };
  };

  const drawLabel = (d) => {
    const no = (d.draw_no ?? '');
    const date = d.draw_date || '';
    return `${no ? ('#' + no + ' ‚Ä¢ ') : ''}${date}`.trim();
  };

  const fmtWinningLine = (d, gameCode) => {
    const g = getGame(gameCode);
    const main = (d.main_numbers || []).join(' ');
    const b = d.bonus_number;
    return `${main}${(g.bonusLabel && b!=null) ? (' + ' + g.bonusLabel + ' ' + b) : ''}`.trim();
  };

  // ----- Data loading
  const fetchJson = async (url) => {
    const res = await fetch(url, { cache: 'no-store' });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  };

  const loadLatestForGame = async (gameCode) => {
    const g = getGame(gameCode);
    if(!g.dataKey) return null;
    const w = await fetchJson(`./data/${g.dataKey}_latest.json`);
    const n = normalizeDraw(gameCode, w);
    return n;
  };

  const loadHistoryForGame = async (gameCode) => {
    const g = getGame(gameCode);
    if(!g.dataKey) return null;

    const data = await fetchJson(`./data/${g.dataKey}_history.json`);
    const drawsRaw = Array.isArray(data) ? data : (Array.isArray(data.draws) ? data.draws : []);
    const meta = Array.isArray(data) ? {} : (data.meta || { source: data.source || '' });

    const draws = drawsRaw.map(d => normalizeDraw(gameCode, d)).filter(Boolean);
    return { meta, draws };
  };

  const loadStatsForGame = async (gameCode) => {
    const g = getGame(gameCode);
    if(!g.dataKey) return null;
    const stats = await fetchJson(`./data/${g.dataKey}_stats.json`);
    return stats;
  };

  // ----- Matching logic
  const computeMatch = (pick, draw) => {
    const g = getGame(pick.game);

    const winMain = (draw.main_numbers || []).map(Number);
    const winBonus = (draw.bonus_number ?? null);

    const pickMain = (pick.numbers || []).map(Number).filter(n => Number.isFinite(n));
    const pickBonus = (pick.bonus ?? null);

    const mainMatches = pickMain.filter(n => winMain.includes(Number(n)));

    let bonusMatch = false;
    if(g.bonusLabel && pickBonus != null && winBonus != null){
      bonusMatch = (Number(pickBonus) === Number(winBonus));
    }

    // score: main match count + (bonus match gives +2 so it breaks ties)
    const score = mainMatches.length + (bonusMatch ? 2 : 0);
    return { mainMatches, bonusMatch, score };
  };

  const bestMatchAllTime = (pick, draws) => {
    if(!draws || !draws.length) return null;
    const scored = draws.map(d => ({ d, ...computeMatch(pick, d) }));
    scored.sort((a,b)=>{
      if(b.mainMatches.length !== a.mainMatches.length) return b.mainMatches.length - a.mainMatches.length;
      if((b.bonusMatch?1:0) !== (a.bonusMatch?1:0)) return (b.bonusMatch?1:0) - (a.bonusMatch?1:0);
      const da = toTime(a.d.draw_date) || 0;
      const db = toTime(b.d.draw_date) || 0;
      return db - da;
    });
    return scored[0];
  };

  const bestMatchSinceSaved = (pick, draws) => {
    if(!draws || !draws.length) return { startISO:'', considered:0, best:null };
    const startISO = getPickStartDateISO(pick);
    const startMs = startISO ? (toTime(startISO) || 0) : 0;

    const pool = draws.filter(d => (toTime(d.draw_date) || 0) >= startMs);
    if(!pool.length) return { startISO, considered:0, best:null };

    const best = bestMatchAllTime(pick, pool);
    return { startISO, considered: pool.length, best };
  };

  const latestHistoryDraw = (draws) => {
    if(!draws || !draws.length) return null;
    let best = null;
    let bestT = -Infinity;
    for (const d of draws) {
      const t = toTime(d.draw_date);
      if(Number.isFinite(t) && t > bestT) { bestT = t; best = d; }
    }
    return best;
  };

  // ----- UI renderers
  const renderLatest = (w, gameCode) => {
    latestPills.innerHTML = '';
    const g = getGame(gameCode);

    if(!w){
      latestMeta.textContent = 'No auto data available yet for this game.';
      return;
    }

    latestMeta.textContent = `${g.name} ‚Ä¢ Draw: ${fmtDate(w.draw_date)}`;
    (w.main_numbers || []).forEach(n => latestPills.appendChild(pill(n)));
    if(w.bonus_number != null){
      latestPills.appendChild(pill(`${g.bonusLabel || 'Bonus'} ${w.bonus_number}`));
    }
  };

  const fillWinningInputs = (w, gameCode) => {
    const g = getGame(gameCode);
    if(!w){
      winMainInput.value = '';
      winBonusInput.value = '';
      winBonusInput.placeholder = g.bonusLabel ? `e.g., 6` : '';
      return;
    }
    winMainInput.value = (w.main_numbers || []).join(' ');
    winBonusInput.value = (w.bonus_number != null) ? String(w.bonus_number) : '';
    winBonusInput.placeholder = g.bonusLabel ? `e.g., ${w.bonus_number || 6}` : '';
  };

  const renderStats = (stats, gameCode) => {
    hotPills.innerHTML = '';
    hotMatchHint.textContent = '';

    if(!stats){
      hotMeta.textContent = 'No stats available yet.';
      return;
    }

    hotMeta.textContent = `Top frequent numbers (${stats.window || 'history'}).`;

    const hotMain = (stats.hot_main || []).slice(0, 10);
    const hotBonus = (stats.hot_bonus || []).slice(0, 5);

    const pickMain = new Set((currentPick?.numbers || []).map(Number));
    hotMain.forEach(n => hotPills.appendChild(pill(n, pickMain.has(Number(n)))));

    if(hotBonus.length){
      const g = getGame(gameCode);
      hotPills.appendChild(pill('‚Äî', false));
      const bonus = (currentPick?.bonus ?? null);
      hotBonus.forEach(n => {
        const hit = (bonus != null) ? (Number(bonus) === Number(n)) : false;
        hotPills.appendChild(pill(`${g.bonusLabel || 'Bonus'} ${n}`, hit));
      });
    }

    if(currentPick){
      const matches = hotMain.filter(n => (currentPick.numbers||[]).map(Number).includes(Number(n)));
      hotMatchHint.textContent = matches.length
        ? `Your pick shares ${matches.length} hot number(s): ${matches.join(', ')}`
        : 'Your pick shares no hot main numbers (in this demo list).';
    }
  };

  const buildWhyHtml = (pick) => {
    const day = getPickStartDateISO(pick) || '‚Äî';
    const emojis = Array.isArray(pick.emojis) ? pick.emojis.join(' ') : '';
    const nums = Array.isArray(pick.numbers) ? pick.numbers.join('-') : '';
    const b = (pick.bonus != null && pick.bonus !== '') ? String(pick.bonus) : '';
    const g = getGame(pick.game);
    const note = `This pick was generated from your emoji choices. The emoji‚Üínumber mapping changes each day, so the same emojis on a different day may produce different numbers.`;
    return `
      <div style="font-weight:800;">Why this pick looks like this</div>
      <div class="hint" style="margin-top:6px;">Emojis: ${esc(emojis||'‚Äî')} ‚Ä¢ Numbers: ${esc(nums||'‚Äî')}${b?` + ${esc(g.bonusLabel||'Bonus')} ${esc(b)}`:''} ‚Ä¢ Saved: ${esc(day)}</div>
      <div class="hint" style="margin-top:8px;">${esc(note)}</div>
    `;
  };

  const renderInsights = () => {
    if(!insightsCard) return;

    if(!currentPick){
      insightsCard.style.display = 'none';
      return;
    }
    insightsCard.style.display = '';
    whyBox.innerHTML = buildWhyHtml(currentPick);

    // Need history to compute best records
    if(!currentHistory || !Array.isArray(currentHistory.draws) || !currentHistory.draws.length){
      challengeBox.innerHTML =
        `<div style="font-weight:800;">Challenge score</div>` +
        `<div class="hint" style="margin-top:6px;">History dataset not available yet for this game.</div>`;
      return;
    }

    const g = getGame(currentPick.game);
    const startISO = getPickStartDateISO(currentPick);
    const latest = latestHistoryDraw(currentHistory.draws);

    // If pick date is later than latest known draw -> not drawn yet
    const pickT = startISO ? toTime(startISO) : NaN;
    const latestT = latest ? toTime(latest.draw_date) : NaN;

    const allBest = bestMatchAllTime(currentPick, currentHistory.draws);
    const since = bestMatchSinceSaved(currentPick, currentHistory.draws);

    const formatBestLine = (bestObj) => {
      if(!bestObj) return `0/${g.mainCount} main` + (g.bonusLabel ? ` ¬∑ ${g.bonusLabel}: ‚Äî` : '');
      const mm = bestObj.mainMatches.length;
      const bb = bestObj.bonusMatch ? '‚úÖ' : '‚Äî';
      return `${mm}/${g.mainCount} main` + (g.bonusLabel ? ` ¬∑ ${g.bonusLabel}: ${bb}` : '');
    };

    const allLine = allBest
      ? `${formatBestLine(allBest)} on <b>${esc(drawLabel(allBest.d))}</b>`
      : `${formatBestLine(null)} (no history yet)`;

    let sinceLine = '';
    if (Number.isFinite(pickT) && Number.isFinite(latestT) && pickT > latestT) {
      // future pick relative to history
      sinceLine = `Not drawn yet (latest recorded draw is <b>${esc(drawLabel(latest))}</b>).`;
    } else {
      const best = since.best;
      if(!best){
        sinceLine = `No draws found on/after <b>${esc(startISO||'your save date')}</b> in this dataset.`;
      } else {
        sinceLine = `${formatBestLine(best)} on <b>${esc(drawLabel(best.d))}</b> (scanned ${esc(since.considered)} draws).`;
      }
    }

    challengeBox.innerHTML = `
      <div style="font-weight:800;">Challenge score</div>
      <div class="hint" style="margin-top:6px;">
        <b>All-time best:</b> ${allLine}
      </div>
      <div class="hint" style="margin-top:8px;">
        <b>Since saved (${esc(startISO||'‚Äî')}):</b> ${sinceLine}
      </div>
      <div class="hint" style="margin-top:10px;">
        Tip: ‚ÄúAll-time best‚Äù is your overall best record in the available history. ‚ÄúSince saved‚Äù is meaningful after the draw dates pass.
      </div>
    `;
  };

  const renderClosestAndHistory = () => {
    if(!currentPick){
      closestMeta.textContent = 'Choose a saved pick to see closest past draws.';
      closestLegend.textContent = '';
      closestList.innerHTML = '';
      historyMeta.textContent = '';
      historyTbody.innerHTML = '';
      historyCountHint.textContent = '';
      return;
    }

    if(!currentHistory || !Array.isArray(currentHistory.draws) || !currentHistory.draws.length){
      closestMeta.textContent = 'History dataset not available yet for this game.';
      closestLegend.textContent = '';
      closestList.innerHTML = '<div class="hint">Tip: when history JSON grows, this list becomes more useful.</div>';
      historyMeta.textContent = 'History dataset not available yet.';
      historyTbody.innerHTML = '';
      historyCountHint.textContent = '';
      return;
    }

    const gameCode = currentPick.game;
    const draws = currentHistory.draws;
    const g = getGame(gameCode);

    // score all draws
    const scored = draws.map(d => ({ d, ...computeMatch(currentPick, d) }));

    // Closest: show only those with at least 1 match (or bonus match)
    const matched = scored.filter(x => x.mainMatches.length > 0 || x.bonusMatch);

    matched.sort((a,b)=>{
      if(b.score !== a.score) return b.score - a.score;
      if(b.mainMatches.length !== a.mainMatches.length) return b.mainMatches.length - a.mainMatches.length;
      const da = toTime(a.d.draw_date) || 0;
      const db = toTime(b.d.draw_date) || 0;
      return db - da;
    });

    const top = matched.slice(0, 10);
    const src = (currentHistory.meta && (currentHistory.meta.source || currentHistory.meta.note)) ? String(currentHistory.meta.source || currentHistory.meta.note) : '';
    const srcHint = (src && !src.includes('demo/') && !src.includes('demo_synthetic')) ? ` Source: ${src}` : '';

    closestMeta.textContent = top.length
      ? `Top ${top.length} closest past draws (sorted by match score).${srcHint}`
      : `No past draws matched any of your numbers in this dataset.${srcHint}`;

    closestLegend.textContent = g.bonusLabel ? `Legend: ${g.bonusLabel}: ‚úÖ = matched, ‚Äî = not matched.` : '';

    if(!top.length){
      closestList.innerHTML = '<div class="hint">No matches found. Try another saved pick.</div>';
    } else {
      closestList.innerHTML = '';
      top.forEach(x => {
        const row = document.createElement('div');
        row.style.padding = '10px 0';
        row.style.borderBottom = '1px solid #E5E7EB';
        const label = drawLabel(x.d);
        const matchText = `${x.mainMatches.length}/${g.mainCount} main` + (g.bonusLabel ? ` ¬∑ ${g.bonusLabel}: ${x.bonusMatch ? '‚úÖ' : '‚Äî'}` : '');
        row.innerHTML = `
          <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;">
            <div>
              <div style="font-weight:800;">${esc(label)}</div>
              <div class="hint">Winning: ${esc(fmtWinningLine(x.d, gameCode))}</div>
            </div>
            <div style="font-weight:800;">${esc(matchText)}</div>
          </div>
          <div class="hint" style="margin-top:6px;">Matched: ${x.mainMatches.length ? esc(x.mainMatches.join(', ')) : '‚Äî'}</div>
        `;
        closestList.appendChild(row);
      });
    }

    // Full history table (search + paging)
    const q = (historySearch.value || '').trim().toLowerCase();
    const all = draws.slice().sort((a,b)=>{
      const da = toTime(a.draw_date) || 0;
      const db = toTime(b.draw_date) || 0;
      return db - da;
    });

    historyFiltered = q
      ? all.filter(d => (`${d.draw_no||''} ${d.draw_date||''}`.toLowerCase().includes(q)))
      : all;

    if(historyShown === 0) historyShown = Math.min(HISTORY_PAGE, historyFiltered.length);

    const show = historyFiltered.slice(0, historyShown);
    historyMeta.textContent = `Showing ${show.length} of ${historyFiltered.length} draws.`;

    historyTbody.innerHTML = '';
    show.forEach(d => {
      const m = computeMatch(currentPick, d);
      const tr = document.createElement('tr');
      tr.style.borderBottom = '1px solid #E5E7EB';

      const dateCol = document.createElement('td');
      dateCol.style.padding='10px';
      dateCol.innerHTML = `<div style="font-weight:800;">${esc(fmtDate(d.draw_date||''))}</div>`;

      const drawCol = document.createElement('td');
      drawCol.style.padding='10px';
      drawCol.textContent = String(d.draw_no ?? '');

      const winCol = document.createElement('td');
      winCol.style.padding='10px';
      winCol.textContent = fmtWinningLine(d, gameCode);

      const matchCol = document.createElement('td');
      matchCol.style.padding='10px';
      matchCol.innerHTML = g.bonusLabel
        ? `${m.mainMatches.length}/${g.mainCount} main ¬∑ ${g.bonusLabel}: ${m.bonusMatch ? '‚úÖ' : '‚Äî'}`
        : `${m.mainMatches.length}/${g.mainCount} main`;

      tr.appendChild(dateCol);
      tr.appendChild(drawCol);
      tr.appendChild(winCol);
      tr.appendChild(matchCol);
      historyTbody.appendChild(tr);
    });

    historyCountHint.textContent = 'Tip: use search, then Load more to browse deeper history.';
  };

  // -------- Compare UI
  const parseNums = (s) => {
    if(!s) return [];
    return s
      .replace(/[^0-9,\s]+/g,' ')
      .split(/[\s,]+/)
      .filter(Boolean)
      .map(x => parseInt(x, 10))
      .filter(n => Number.isFinite(n));
  };

  const doCompare = () => {
    if(!currentPick){
      results.style.display = 'block';
      results.innerHTML = '<strong>Please choose a saved pick first.</strong>';
      return;
    }

    const gameCode = currentPick.game;
    const g = getGame(gameCode);

    const winMain = parseNums(winMainInput.value);
    const winBonus = parseNums(winBonusInput.value)[0];

    if(winMain.length !== g.mainCount){
      results.style.display = 'block';
      results.innerHTML = `<strong>Winning main numbers must contain exactly ${g.mainCount} numbers.</strong>`;
      return;
    }

    const pickMain = (currentPick.numbers || []).map(Number);
    const pickBonus = (currentPick.bonus ?? null);

    const mainMatches = pickMain.filter(n => winMain.includes(Number(n)));
    const bonusMatch = (pickBonus != null && Number.isFinite(winBonus))
      ? (Number(pickBonus) === Number(winBonus))
      : false;

    results.style.display = 'block';
    results.innerHTML = `
      <div style="font-weight:800;">Match result</div>
      <div class="hint">Pick: ${pickMain.join(' ')}${(pickBonus!=null && pickBonus!=='') ? ` + ${g.bonusLabel||'Bonus'} ${pickBonus}` : ''}</div>
      <div class="hint">Winning: ${winMain.join(' ')}${(Number.isFinite(winBonus)) ? ` + ${g.bonusLabel||'Bonus'} ${winBonus}` : ''}</div>
      <div style="margin-top:10px;">Main matches: <strong>${mainMatches.length}</strong> ${mainMatches.length ? `(${mainMatches.join(', ')})` : ''}</div>
      <div>Bonus match: <strong>${bonusMatch ? 'Yes' : 'No'}</strong></div>
      <div class="hint" style="margin-top:8px;">For fun only ‚Äî no prediction or improved odds.</div>
    `;

    results.scrollIntoView({ behavior: 'smooth', block: 'start' });
    results.style.boxShadow = '0 0 0 3px rgba(17,24,39,.15)';
    setTimeout(() => { results.style.boxShadow = ''; }, 700);

    renderClosestAndHistory();
    renderInsights();
    renderSavedPicksHistory(); // refresh best records column
  };

  // -------- Auto refresh data
  const refreshAutoData = async () => {
    if(!currentPick){
      renderLatest(null, 'pb');
      fillWinningInputs(null, 'pb');
      renderStats(null, 'pb');
      renderClosestAndHistory();
      if(insightsCard) insightsCard.style.display = 'none';
      return;
    }

    const gameCode = currentPick.game;

    try{
      if(!gameLatestCache.has(gameCode)){
        const latest = await loadLatestForGame(gameCode);
        gameLatestCache.set(gameCode, latest);
      }
      currentWinning = gameLatestCache.get(gameCode) || null;
    }catch{ currentWinning = null; }

    try{
      if(!gameStatsCache.has(gameCode)){
        const stats = await loadStatsForGame(gameCode);
        gameStatsCache.set(gameCode, stats);
      }
      currentStats = gameStatsCache.get(gameCode) || null;
    }catch{ currentStats = null; }

    try{
      if(!gameHistoryCache.has(gameCode)){
        const hist = await loadHistoryForGame(gameCode);
        gameHistoryCache.set(gameCode, hist);
      }
      currentHistory = gameHistoryCache.get(gameCode) || null;
    }catch{ currentHistory = null; }

    renderLatest(currentWinning, gameCode);
    fillWinningInputs(currentWinning, gameCode);
    renderStats(currentStats, gameCode);
    renderClosestAndHistory();
    renderInsights();
    renderSavedPicksHistory();

    // Auto-compare when auto data is present
    if(currentWinning){
      doCompare();
    }
  };

  const onPickChanged = async () => {
    const idx = parseInt(pickSelect.value, 10);
    currentPick = Number.isFinite(idx) ? picks[idx] : null;

    historyShown = 0;
    if(historySearch) historySearch.value = '';
    results.style.display = 'none';

    await refreshAutoData();
  };

  // -------- Saved picks history table
  const bestRecordsText = (pick) => {
    const g = getGame(pick.game);
    const hist = gameHistoryCache.get(pick.game);
    if(!hist || !hist.draws || !hist.draws.length){
      return `<span class="hint">History not loaded yet.</span>`;
    }
    const all = bestMatchAllTime(pick, hist.draws);
    const since = bestMatchSinceSaved(pick, hist.draws);
    const latest = latestHistoryDraw(hist.draws);

    const fmt = (bestObj) => {
      if(!bestObj) return `0/${g.mainCount} main` + (g.bonusLabel ? ` ¬∑ ${g.bonusLabel}: ‚Äî` : '');
      return `${bestObj.mainMatches.length}/${g.mainCount} main` + (g.bonusLabel ? ` ¬∑ ${g.bonusLabel}: ${bestObj.bonusMatch ? '‚úÖ' : '‚Äî'}` : '');
    };

    const allLine = all ? `${fmt(all)} (${esc(drawLabel(all.d))})` : fmt(null);
    const startISO = getPickStartDateISO(pick);
    const pickT = startISO ? toTime(startISO) : NaN;
    const latestT = latest ? toTime(latest.draw_date) : NaN;

    let sinceLine = '';
    if(Number.isFinite(pickT) && Number.isFinite(latestT) && pickT > latestT){
      sinceLine = `Not drawn yet`;
    } else {
      sinceLine = since.best ? `${fmt(since.best)} (${esc(drawLabel(since.best.d))})` : `0/${g.mainCount} main`;
    }

    return `
      <div><b>All-time:</b> ${allLine}</div>
      <div class="hint" style="margin-top:4px;"><b>Since saved:</b> ${sinceLine}</div>
    `;
  };

  const renderSavedPicksHistory = () => {
    if(!picks || !picks.length){
      if(picksHistoryCard) picksHistoryCard.style.display = 'none';
      return;
    }
    if(picksHistoryCard) picksHistoryCard.style.display = '';

    const q = (picksSearch.value || '').trim().toLowerCase();

    const filtered = q ? picks.filter(p=>{
      const saved = getPickStartDateISO(p);
      const g = getGame(p.game).name;
      const em = (p.emojis||[]).join(' ');
      const nums = (p.numbers||[]).join(' ');
      const b = (p.bonus!=null ? String(p.bonus) : '');
      return `${saved} ${g} ${em} ${nums} ${b}`.toLowerCase().includes(q);
    }) : picks.slice();

    picksTbody.innerHTML = '';
    filtered.forEach((p, idxOriginal) => {
      // idxOriginal must map to original picks index
      const idx = picks.indexOf(p);
      const tr = document.createElement('tr');
      tr.className = 'clickable';
      tr.addEventListener('click', ()=>{
        pickSelect.value = String(idx);
        onPickChanged();
        // scroll to step 1 area
        pickSelect.scrollIntoView({ behavior:'smooth', block:'center' });
      });

      const saved = getPickStartDateISO(p);
      const g = getGame(p.game);
      const nums = (p.numbers||[]).join('-');
      const b = (p.bonus!=null && p.bonus!=='') ? ` + ${g.bonusLabel} ${p.bonus}` : '';
      const emojis = (p.emojis||[]).join(' ');

      tr.innerHTML = `
        <td><div style="font-weight:800;">${esc(saved || '‚Äî')}</div></td>
        <td><div style="font-weight:800;">${esc(g.name)}</div></td>
        <td>
          <div style="font-weight:800;">${esc(nums)}${esc(b)}</div>
          <div class="hint" style="margin-top:4px;">${esc(emojis || '‚Äî')}</div>
        </td>
        <td>${bestRecordsText(p)}</td>
      `;
      picksTbody.appendChild(tr);
    });

    picksCountHint.textContent = `Showing ${filtered.length} of ${picks.length} saved picks.`;
  };

  // -------- Share text
  const buildShareText = () => {
    if(!currentPick) return '';
    const g = getGame(currentPick.game);
    const emojis = Array.isArray(currentPick.emojis) ? currentPick.emojis.join(' ') : '';
    const nums = Array.isArray(currentPick.numbers) ? currentPick.numbers.join('-') : '';
    const b = (currentPick.bonus != null && currentPick.bonus !== '') ? String(currentPick.bonus) : '';
    const day = getPickStartDateISO(currentPick) || '';

    let bestLine = '';
    if(currentHistory && Array.isArray(currentHistory.draws) && currentHistory.draws.length){
      const best = bestMatchAllTime(currentPick, currentHistory.draws);
      if(best){
        const t = `${best.mainMatches.length}/${g.mainCount} main` + (g.bonusLabel ? `, ${g.bonusLabel} ${best.bonusMatch ? 'MATCH' : 'no'}` : '');
        bestLine = `\nBest all-time match: ${t} on ${drawLabel(best.d)}`;
      }
    }

    return `EmojiPick ‚Äî ${g.name}${day?` (${day})`:''}
Emojis: ${emojis||'-'}
Numbers: ${nums}${b?` + ${g.bonusLabel||'Bonus'} ${b}`:''}${bestLine}

(For fun only ‚Äî no prediction or improved odds.)`;
  };

  // -------- Events
  if (historyToggle && historyWrap) {
    historyToggle.addEventListener('click', () => {
      const isHidden = (historyWrap.style.display === 'none' || !historyWrap.style.display);
      historyWrap.style.display = isHidden ? 'block' : 'none';
      historyToggle.textContent = isHidden ? 'Hide' : 'Show';
    });
  }

  manualToggle.addEventListener('change', () => setManualEnabled(manualToggle.checked));
  refreshLatestBtn.addEventListener('click', async () => refreshAutoData());
  pickSelect.addEventListener('change', onPickChanged);

  if (sharePickBtn) {
    const SHARE_HINT_DEFAULT = shareHint ? shareHint.textContent : '';
    sharePickBtn.addEventListener('click', async () => {
      const text = buildShareText();
      if (!text) return;
      try {
        await navigator.clipboard.writeText(text);
        if (shareHint) {
          shareHint.textContent = 'Copied to clipboard.';
          setTimeout(() => (shareHint.textContent = SHARE_HINT_DEFAULT), 1800);
        }
      } catch {
        window.prompt('Copy this text:', text);
      }
    });
  }

  compareBtn.addEventListener('click', () => doCompare());

  clearBtn.addEventListener('click', () => {
    winMainInput.value = '';
    winBonusInput.value = '';
    results.style.display = 'none';
  });

  if(historySearch){
    historySearch.addEventListener('input', () => {
      historyShown = 0;
      renderClosestAndHistory();
    });
  }
  if(historyClear){
    historyClear.addEventListener('click', () => {
      if(historySearch) historySearch.value = '';
      historyShown = 0;
      renderClosestAndHistory();
    });
  }
  if(historyMore){
    historyMore.addEventListener('click', () => {
      const total = historyFiltered.length || 0;
      historyShown = Math.min((historyShown || 0) + HISTORY_PAGE, total);
      renderClosestAndHistory();
    });
  }

  // picks history toggle/search
  if(picksToggle && picksHistoryWrap){
    picksToggle.addEventListener('click', ()=>{
      const hidden = (picksHistoryWrap.style.display === 'none' || !picksHistoryWrap.style.display);
      picksHistoryWrap.style.display = hidden ? 'block' : 'none';
      picksToggle.textContent = hidden ? 'Hide' : 'Show';
    });
  }
  if(picksSearch){
    picksSearch.addEventListener('input', renderSavedPicksHistory);
  }
  if(picksClear){
    picksClear.addEventListener('click', ()=>{
      if(picksSearch) picksSearch.value = '';
      renderSavedPicksHistory();
    });
  }

  // -------- Init
  picks = readPicks();
  renderPickDropdown();
  setManualEnabled(false);
  renderSavedPicksHistory();

  if(picks.length){
    pickSelect.value = '0';
    onPickChanged();
  } else {
    // no picks
    if(picksHistoryCard) picksHistoryCard.style.display = 'none';
    renderLatest(null, 'pb');
    fillWinningInputs(null, 'pb');
    renderStats(null, 'pb');
  }

})();
</script>
</body>
</html>
